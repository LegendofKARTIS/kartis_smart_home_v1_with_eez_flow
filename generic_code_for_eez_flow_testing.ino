#include <Arduino.h>
#include <lvgl.h>
#include <TFT_eSPI.h>

// ---------- IMPORTANT ----------
// DO NOT wrap EEZ headers with extern "C".
// EEZ generated headers use C++ features (templates, namespaces).
// Include them normally:
#include "ui.h"        // generated by EEZ Studio (ui.c / ui.h must be in project)


// Calibration constants
const uint16_t RAW_MIN_X = 429;
const uint16_t RAW_MAX_X = 3593;
const uint16_t RAW_MIN_Y = 1905;
const uint16_t RAW_MAX_Y = 3345;

const bool SWAP_AXES = false;
const bool INVERT_X  = false;
const bool INVERT_Y  = true;
static lv_obj_t *temperature_arc_obj = NULL;


// ---------------- Display ----------------
TFT_eSPI tft = TFT_eSPI();

static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[320 * 20];


static inline int32_t fmap_clamped(int32_t val, int32_t in_min, int32_t in_max,
                                   int32_t out_min, int32_t out_max) {
    if (in_max == in_min) return out_min;

    long mapped = (long)(val - in_min) * (out_max - out_min) /
                  (long)(in_max - in_min) + out_min;

    if (mapped < out_min) return out_min;
    if (mapped > out_max) return out_max;
    return (int32_t)mapped;
}

// ---------------- Flush ----------------
void my_disp_flush(lv_disp_drv_t *disp,
                   const lv_area_t *area,
                   lv_color_t *color_p){
  uint32_t w = (uint32_t)(area->x2 - area->x1 + 1);
  uint32_t h = (uint32_t)(area->y2 - area->y1 + 1);

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors((uint16_t *)color_p, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp);
}
void my_touch_read(lv_indev_drv_t *indev, lv_indev_data_t *data) {
    uint16_t tx = 0, ty = 0;
    bool pressed = tft.getTouch(&tx, &ty);

    const uint16_t sw = tft.width();   // 320
    const uint16_t sh = tft.height();  // 240

    if (!pressed) {
        data->state = LV_INDEV_STATE_REL;
        return;
    }

    data->state = LV_INDEV_STATE_PR;

    bool scaled = (tx <= sw && ty <= sh);

    int32_t mx, my;

    if (scaled) {
        mx = SWAP_AXES ? ty : tx;
        my = SWAP_AXES ? tx : ty;
    } else {
        if (SWAP_AXES) {
            mx = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sw);
            my = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sh);
        } else {
            mx = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sw);
            my = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sh);
        }
    }

    if (INVERT_X) mx = sw - mx;
    if (INVERT_Y) my = sh - my;

    if (mx < 0) mx = 0;
    if (mx > sw) mx = sw;
    if (my < 0) my = 0;
    if (my > sh) my = sh;

    data->point.x = (lv_coord_t)mx;
    data->point.y = (lv_coord_t)my;

    Serial.printf("TOUCH RAW: %u %u | MAPPED: %ld %ld\n", tx, ty, mx, my);
}


// ---------------- Setup ----------------
void setup()
{
  Serial.begin(115200);
  delay(50);

  tft.begin();
  tft.setRotation(1);

  lv_init();

  // Display driver
  lv_disp_draw_buf_init(&draw_buf, buf1, NULL, 320 * 20);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  disp_drv.hor_res = 320;
  disp_drv.ver_res = 240;
  lv_disp_drv_register(&disp_drv);

  // Touch driver (pointer)
  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touch_read;
  lv_indev_drv_register(&indev_drv);

  // ----- EEZ: initialize UI + Flow (ui_init is generated by EEZ) -----
  // Make sure ui.c/.cpp and the rest of the EEZ-generated files are present in the sketch.
  ui_init();
  Serial.println("ui_init() done");
}

// ---------------- Loop ----------------
void loop(){
  static uint32_t last = 0;
  uint32_t now = millis();

  // lvgl tick
  if (now - last >= 5) {
    lv_tick_inc(5);
    last = now;
  }

  // ---------- CRITICAL: call the EEZ-generated tick entrypoint ----------
  // Use ui_tick() (generated by EEZ) â€” it drives the flow engine and widget updates.
  ui_tick();

  // Let LVGL perform its periodic tasks and redraw
  lv_timer_handler();

  delay(1);
}
