#include <Arduino.h>
#include <lvgl.h>
#include <TFT_eSPI.h>

// ---------- IMPORTANT ----------
// DO NOT wrap EEZ headers with extern "C".
// EEZ generated headers use C++ features (templates, namespaces).
// Include them normally:
#include "ui.h"        // generated by EEZ Studio (ui.c / ui.h must be in project)

#include "vars.h"      // üî• THIS WAS MISSING
#include "eez-flow.h"
#include <Wire.h>

#include <RTClib.h>
#include <DHT.h>

// Calibration constants
const uint16_t RAW_MIN_X = 429;
const uint16_t RAW_MAX_X = 3593;
const uint16_t RAW_MIN_Y = 1905;
const uint16_t RAW_MAX_Y = 3345;

const bool SWAP_AXES = false;
const bool INVERT_X  = false;
const bool INVERT_Y  = true;
static lv_obj_t *temperature_arc_obj = NULL;


// --- DHT CONFIG ---
#define DHT_PIN 27         // change this to the GPIO you actually use
#define DHT_TYPE DHT11     // DHT11
#define LDR_PIN 14   // ADC pin you're using
#define buzzerPin 12
DHT dht(DHT_PIN, DHT_TYPE);

// reading interval
const unsigned long Sensor_Read_Interval = 5000UL;
static unsigned long lastSensorMs = 0;


int ldrRaw = 0;      // raw value
int ldrPercent = 0;  // 0‚Äì100% scaled value

// tune these two based on your real readings:
const int LDR_MIN = 0;   // darkest reading
const int LDR_MAX = 700;  // brightest reading
static char hourStr[3];    // "00" + null
static char minuteStr[3];  // "00" + null


// ---------- MQ135 integration (drop into your existing sensor code) ----------
#define MQ_PIN        34        // change to your MQ135 ADC pin
#define MQ_ADC_MAX    4095      // ESP32 12-bit ADC default; change to 1023 for 10-bit boards
#define MQ_RAW_MIN    0         // raw value corresponding to "clean" (calibrate later)
#define MQ_RAW_MAX    3000      // raw value that you treat as very bad (calibrate)

// optional smoothing (exponential moving average) to reduce jitter
#define MQ_SMOOTHING_ENABLED 1
#define MQ_ALPHA 0.2f           // 0..1 (higher = more responsive, lower = smoother)
static float mq_ema = -1.0f;    // holds EMA state

RTC_DS3231 rtc;

int hour, minute, date, month, dow;
// Month names (short) ‚Äî safe to pass to set_var_month()
static const char *month_names[] = {
  "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};
static const char *weekday_names[] = {
  "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"
};


// --- Relay pin configuration ---
#define RELAY_LIGHT_PIN 15  // physical pin for light relay (D15)
#define RELAY_FAN_PIN    35  // physical pin for fan relay (D4)
// Set true if relays are active-low (most common). Set false if active-high.
#define RELAY_ACTIVE_LOW false

static inline void relay_hw_write(uint8_t pin, bool on) {
  if (RELAY_ACTIVE_LOW) digitalWrite(pin, on ? LOW : HIGH);
  else                  digitalWrite(pin, on ? HIGH : LOW);
}

static inline int32_t fmap_clamped(int32_t val, int32_t in_min, int32_t in_max,
                                   int32_t out_min, int32_t out_max) {
    if (in_max == in_min) return out_min;

    long mapped = (long)(val - in_min) * (out_max - out_min) /
                  (long)(in_max - in_min) + out_min;

    if (mapped < out_min) return out_min;
    if (mapped > out_max) return out_max;
    return (int32_t)mapped;
}


// ---------------- Display ----------------
TFT_eSPI tft = TFT_eSPI();

static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[320 * 20];

// ---------------- Flush ----------------
void my_disp_flush(lv_disp_drv_t *disp,
                   const lv_area_t *area,
                   lv_color_t *color_p){
  uint32_t w = (uint32_t)(area->x2 - area->x1 + 1);
  uint32_t h = (uint32_t)(area->y2 - area->y1 + 1);

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors((uint16_t *)color_p, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp);
}
void my_touch_read(lv_indev_drv_t *indev, lv_indev_data_t *data) {
    uint16_t tx = 0, ty = 0;
    bool pressed = tft.getTouch(&tx, &ty);

    const uint16_t sw = tft.width();   // 320
    const uint16_t sh = tft.height();  // 240

    if (!pressed) {
        data->state = LV_INDEV_STATE_REL;
        return;
    }

    data->state = LV_INDEV_STATE_PR;

    bool scaled = (tx <= sw && ty <= sh);

    int32_t mx, my;

    if (scaled) {
        mx = SWAP_AXES ? ty : tx;
        my = SWAP_AXES ? tx : ty;
    } else {
        if (SWAP_AXES) {
            mx = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sw);
            my = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sh);
        } else {
            mx = fmap_clamped(tx, RAW_MIN_X, RAW_MAX_X, 0, sw);
            my = fmap_clamped(ty, RAW_MIN_Y, RAW_MAX_Y, 0, sh);
        }
    }

    if (INVERT_X) mx = sw - mx;
    if (INVERT_Y) my = sh - my;

    if (mx < 0) mx = 0;
    if (mx > sw) mx = sw;
    if (my < 0) my = 0;
    if (my > sh) my = sh;

    data->point.x = (lv_coord_t)mx;
    data->point.y = (lv_coord_t)my;

    Serial.printf("TOUCH RAW: %u %u | MAPPED: %ld %ld\n", tx, ty, mx, my);
}


// ------------------------------------------------------------------
// DO NOT rename these ‚Äî update them in your sensor routines (DHT, MQ135, LDR, RTC)
float sensorTemperature = 32;             // Celsius (e.g. 25.3)
float sensorHumidity    = 85;             // Percent (e.g. 53.4)
int   airQualityRaw     = 0;              // Raw MQ135 reading or AQI-like int
String airQualityStatusStr = "Good";   // "Good", "Super", "Poor", "Toxic", etc.
int   ldrReading        = 44;              // Raw LDR ADC value (or computed lux)
//char  dateStr[32]      = "";               // human-readable date (e.g. "2025-11-30")
//char  dayOfWeekStr[16] = "";               // e.g. "Sun", "Monday"
// Forward prototype so setup() can reference it even if function is below
// ---------------- Setup ----------------

void handleSerialTimeSet() {
    if (!Serial.available()) return;

    String input = Serial.readStringUntil('\n');
    input.trim();

    if (!input.startsWith("SETTIME:")) return;

    // Expected format: SETTIME:YYYY-MM-DD HH:MM:SS
    String payload = input.substring(8);
    int y, M, d, h, m, s;

    if (sscanf(payload.c_str(), "%d-%d-%d %d:%d:%d", &y, &M, &d, &h, &m, &s) == 6) {
        rtc.adjust(DateTime(y, M, d, h, m, s));
        Serial.println("RTC UPDATED ‚úî");
    } else {
        Serial.println("INVALID FORMAT ‚ùå");
    }
}

void sync_relays_from_eez() {
    // Read EEZ Flow variables
    bool light_on = eez::flow::getGlobalVariable(
        FLOW_GLOBAL_VARIABLE_LIGHT_STATE
    ).toBool();
    // Drive hardware
    relay_hw_write(RELAY_LIGHT_PIN, light_on);
}

void setup(){
  Serial.begin(115200);
  delay(50);
  pinMode(buzzerPin, OUTPUT);

        // initialize relays
    pinMode(RELAY_LIGHT_PIN, OUTPUT);
    pinMode(RELAY_FAN_PIN, OUTPUT);
    // default OFF
    if (RELAY_ACTIVE_LOW) {
    digitalWrite(RELAY_LIGHT_PIN, HIGH);
    digitalWrite(RELAY_FAN_PIN, HIGH);
    } else {
    digitalWrite(RELAY_LIGHT_PIN, LOW);
    digitalWrite(RELAY_FAN_PIN, LOW);
    }
  dht.begin();
  int r = analogRead(MQ_PIN);
    mq_ema = (float)r;
          Wire.begin(25, 26); // SDA, SCL (change if you use other pins)
    if (!rtc.begin()) {
        Serial.println("ERROR: Couldn't find DS3231.");
        // handle error or continue (UI still runs)
    } else {
        Serial.println("DS3231 found.");
    }


  tft.begin();
  tft.setRotation(1);

  lv_init();

  // Display driver
  lv_disp_draw_buf_init(&draw_buf, buf1, NULL, 320 * 20);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  disp_drv.hor_res = 320;
  disp_drv.ver_res = 240;
  lv_disp_drv_register(&disp_drv);

  // Touch driver (pointer)
  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touch_read;
  lv_indev_drv_register(&indev_drv);

  // ----- EEZ: initialize UI + Flow (ui_init is generated by EEZ) -----
  // Make sure ui.c/.cpp and the rest of the EEZ-generated files are present in the sketch.
  ui_init();
  Serial.println("ui_init() done");

    // Optional: initialize the sensor placeholder defaults (if you like)
  sensorTemperature = 40;
  sensorHumidity = 85;
  airQualityRaw = 1000;
  ldrReading = 450;


  // ---- FIX ARC RANGE ----
    lv_obj_t *scr = lv_scr_act();
    for (uint32_t i = 0; i < lv_obj_get_child_cnt(scr); i++) {
        lv_obj_t *child = lv_obj_get_child(scr, i);
        if (lv_obj_check_type(child, &lv_arc_class)) {
            temperature_arc_obj = child;
            break;
        }
    }

    if (temperature_arc_obj) {
        lv_arc_set_range(temperature_arc_obj, 0, 100);   // or 0‚Äì50 for temp
        lv_arc_set_value(temperature_arc_obj, 0);        // FORCE start at zero
        Serial.println("Arc range fixed ‚úî");
    } else {
        Serial.println("Arc not found ‚ùå");
    }
if (temperature_arc_obj) {
    // Correct range
    lv_arc_set_range(temperature_arc_obj, 0, 50); // adjust if needed

    // MAIN arc (background)
    lv_obj_set_style_arc_width(
        temperature_arc_obj,
        12,
        LV_PART_MAIN | LV_STATE_DEFAULT
    );

    lv_obj_set_style_arc_color(
        temperature_arc_obj,
        lv_color_hex(0x303030), // dark gray background arc
        LV_PART_MAIN | LV_STATE_DEFAULT
    );

    // INDICATOR arc
    lv_obj_set_style_arc_width(
        temperature_arc_obj,
        12,
        LV_PART_INDICATOR | LV_STATE_DEFAULT
    );

    Serial.println("Arc base style fixed ‚úî");
}

}


// Simple timing for dashboard refresh
static unsigned long lastDashboardMs = 0;
const unsigned long DASH_UPDATE_INTERVAL_MS = 500;

static inline int mq_raw_to_scale(int raw) {
  if (raw <= MQ_RAW_MIN) return 0;
  if (raw >= MQ_RAW_MAX) return 1000;
  long mapped = (long)(raw - MQ_RAW_MIN) * 1000L / (MQ_RAW_MAX - MQ_RAW_MIN);
  if (mapped < 0) mapped = 0;
  if (mapped > 1000) mapped = 1000;
  return (int)mapped;
}

// ----- helper to convert raw LDR to 0..100% -----
static inline int convertLDRtoPercent(int raw) {
  if (raw <= LDR_MIN) return 0;
  if (raw >= LDR_MAX) return 100;
  // map and clamp
  int p = map(raw, LDR_MIN, LDR_MAX, 0, 100);
  if (p < 0) p = 0;
  if (p > 100) p = 100;
  return p;
}

void rtc_poll_nonblocking() {

  DateTime dt = rtc.now();

  // hour, minute, date (day of month), month, dayOfWeek
    hour = dt.hour();        // 0..23
  minute = dt.minute();    // 0..59
  date = dt.day();         // 1..31
  month = dt.month();      // 1..12
  dow  = dt.dayOfTheWeek(); // 0 = Sunday ... 6 = Saturday (RTClib)

  // format hour & minute as 2-digit strings
  snprintf(hourStr, sizeof(hourStr), "%02d", hour);
  snprintf(minuteStr, sizeof(minuteStr), "%02d", minute);

  // send to EEZ Flow as STRING values
  eez::flow::setGlobalVariable(
      FLOW_GLOBAL_VARIABLE_TIME_HOUR,
      eez::Value(hourStr)
  );

  eez::flow::setGlobalVariable(
      FLOW_GLOBAL_VARIABLE_TIME_MINUTE,
      eez::Value(minuteStr)
  );


  eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_DATE, eez::Value((int32_t)date));

  // set month string (EEZ set_var_month expects const char*)
  if (month >= 1 && month <= 12) {
    eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_MONTH, eez::Value(month_names[month-1]));
  } else {
    eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_MONTH, eez::Value("N/A"));
  }

  // Map RTClib dayOfWeek (0=Sun..6=Sat) to your DayOfWeek enum
  // vars.h enum: DayOfWeek_SUN = 0 ... DayOfWeek_SAT = 6
    DayOfWeek dd = (DayOfWeek)dow;
  if (dow >= 0 && dow <= 6) {
    eez::flow::setGlobalVariable(
      FLOW_GLOBAL_VARIABLE_DAYOF_WEEK_VAR,
      eez::Value(weekday_names[dow])
    );
  } else {
    eez::flow::setGlobalVariable(
      FLOW_GLOBAL_VARIABLE_DAYOF_WEEK_VAR,
      eez::Value("N/A")
    );
  }


  // Optional: print for debugging
  Serial.printf("RTC: %02d:%02d  %02d/%02d  DOW=%d\n", hour, minute, date, month, dow);
}

// ----- sensor read routine (call every 5s) -----
void read_sensors_tick() {
  // Read humidity and temperature from DHT (may block for a few ms)
  float t = dht.readTemperature(); // Celsius
  float h = dht.readHumidity();

  // If read failed, keep old values (avoid writing NaN into UI)
  if (!isnan(t)) {
    sensorTemperature = t;                          // keep float used by your update_dashboard()
    // round and set EEZ integer var (function from vars.h)
    eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_TEMPERTURE_VALUE, eez::Value((int32_t)lround(t)));
    // ---- Temperature arc color update (EEZ-safe) ----
    long temp_display = (long)lround(t);
      if (temperature_arc_obj) {
}

    
  } else {
    // optional: log
    Serial.println("DHT readTemperature failed.");
  }

  if (!isnan(h)) {
    sensorHumidity = h;
    eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_HUMIDITY_VALUE, eez::Value((int32_t)lround(h)));
  } else {
    Serial.println("DHT readHumidity failed.");
  }



  // Read LDR raw value and convert to percent
  int raw = analogRead(LDR_PIN);
  int percent = convertLDRtoPercent(raw);

  // update placeholders and EEZ var
  ldrReading = percent;                 // used by update_dashboard() -> objects.light_text
  eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_LDR_VALUE, eez::Value((int32_t)percent));

  int rawMQ = analogRead(MQ_PIN);         // raw ADC
  float raw_f = (float)rawMQ;

  #if MQ_SMOOTHING_ENABLED
  if (mq_ema < 0.0f) mq_ema = raw_f;    // seed if uninitialized
  mq_ema = MQ_ALPHA * raw_f + (1.0f - MQ_ALPHA) * mq_ema;
  int raw_used = (int)lround(mq_ema);
  #else
  int raw_used = raw;
  #endif

  // Map to 0..1000 (same style you used earlier)
  int scaled = mq_raw_to_scale(raw_used);

  // Update placeholders and EEZ vars
  airQualityRaw = scaled;                  // used by your update_dashboard()
  eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_AIR_QUALITY_VALUE, eez::Value((int32_t)scaled));


  // Derive status string (tune thresholds as needed)
  const char *status = "N/A";
  if (scaled >= 0) {
    if (scaled > 800) status = "Toxic";
    else if (scaled > 600) status = "Poor";
    else if (scaled > 300) status = "Good";
    else status = "Fine";
  }
  eez::flow::setGlobalVariable(FLOW_GLOBAL_VARIABLE_AIR_QUALITY_STATUS, eez::Value(status));
  // optional: update label too if you want immediate UI change
  //if (objects.air_quality_status_text) {
  //    lv_label_set_text(objects.air_quality_status_text, status);
 // }
    Serial.printf("SENSORS: T=%.1fC H=%.1f%% LDR_raw=%d LDR%%=%d\n", t, h, raw, percent);
  Serial.printf("MQ135: raw=%d raw_used=%d scaled=%d status=%s\n", raw, raw_used, scaled, status);

}

void loop() {
  static uint32_t last = 0;
  uint32_t now = millis();

  if (now - last >= 5) {
    lv_tick_inc(5);
    last = now;
  }

  ui_tick();
  lv_timer_handler();
  sync_relays_from_eez();


    if (millis() - lastSensorMs >= Sensor_Read_Interval) {
        lastSensorMs = millis();
        read_sensors_tick();
        rtc_poll_nonblocking();
    }
    handleSerialTimeSet();
    delay(1); // Allow other tasks/interrupts to run
}

